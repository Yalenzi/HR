/*! QRCode.js v1.5.3 | (c) 2012 davidshimjs | MIT licensed */
(function() {
    var QRCode = function(element, options) {
        this._el = element;
        this._htOption = Object.assign({
            width: 256,
            height: 256,
            typeNumber: 4,
            colorDark: "#000000",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.M
        }, options);

        if (typeof element === "string") {
            element = document.getElementById(element);
        }

        if (this._htOption.width && element.style) {
            element.style.width = this._htOption.width + "px";
        }

        if (this._htOption.height && element.style) {
            element.style.height = this._htOption.height + "px";
        }

        this._el = element;
        this._oQRCode = null;
        this._oDrawing = new QRCode.Drawing(this._el, this._htOption);

        if (this._htOption.text) {
            this.makeCode(this._htOption.text);
        }
    };

    QRCode.prototype.makeCode = function(sText) {
        this._oQRCode = new QRCode.QRCodeModel(QRCode.Util.getTypeNumber(sText, this._htOption.correctLevel), this._htOption.correctLevel);
        this._oQRCode.addData(sText);
        this._oQRCode.make();
        this._el.title = sText;
        this._oDrawing.draw(this._oQRCode);
        this.makeImage();
    };

    QRCode.prototype.makeImage = function() {
        if (typeof this._oDrawing.makeImage === "function" && (!this._el.getAttribute("title"))) {
            this._el.setAttribute("title", this._htOption.text);
        }
        if (typeof this._oDrawing.makeImage === "function") {
            this._oDrawing.makeImage();
        }
    };

    QRCode.prototype.clear = function() {
        this._oDrawing.clear();
    };

    QRCode.CorrectLevel = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
    };

    // QRCode Model
    QRCode.QRCodeModel = function(typeNumber, errorCorrectLevel) {
        this.typeNumber = typeNumber;
        this.errorCorrectLevel = errorCorrectLevel;
        this.modules = null;
        this.moduleCount = 0;
        this.dataCache = null;
        this.dataList = [];
    };

    QRCode.QRCodeModel.prototype = {
        addData: function(data) {
            var newData = new QRCode.QRCode8bitByte(data);
            this.dataList.push(newData);
            this.dataCache = null;
        },

        isDark: function(row, col) {
            if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
                throw new Error(row + "," + col);
            }
            return this.modules[row][col];
        },

        getModuleCount: function() {
            return this.moduleCount;
        },

        make: function() {
            this.makeImpl(false, this.getBestMaskPattern());
        },

        makeImpl: function(test, maskPattern) {
            this.moduleCount = this.typeNumber * 4 + 17;
            this.modules = new Array(this.moduleCount);

            for (var row = 0; row < this.moduleCount; row++) {
                this.modules[row] = new Array(this.moduleCount);
                for (var col = 0; col < this.moduleCount; col++) {
                    this.modules[row][col] = null;
                }
            }

            this.setupPositionProbePattern(0, 0);
            this.setupPositionProbePattern(this.moduleCount - 7, 0);
            this.setupPositionProbePattern(0, this.moduleCount - 7);
            this.setupPositionAdjustPattern();
            this.setupTimingPattern();
            this.setupTypeInfo(test, maskPattern);

            if (this.typeNumber >= 7) {
                this.setupTypeNumber(test);
            }

            if (this.dataCache == null) {
                this.dataCache = QRCode.QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
            }

            this.mapData(this.dataCache, maskPattern);
        },

        setupPositionProbePattern: function(row, col) {
            for (var r = -1; r <= 7; r++) {
                if (row + r <= -1 || this.moduleCount <= row + r) continue;

                for (var c = -1; c <= 7; c++) {
                    if (col + c <= -1 || this.moduleCount <= col + c) continue;

                    if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
                        (0 <= c && c <= 6 && (r == 0 || r == 6)) ||
                        (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                        this.modules[row + r][col + c] = true;
                    } else {
                        this.modules[row + r][col + c] = false;
                    }
                }
            }
        },

        getBestMaskPattern: function() {
            var minLostPoint = 0;
            var pattern = 0;

            for (var i = 0; i < 8; i++) {
                this.makeImpl(true, i);
                var lostPoint = QRCode.Util.getLostPoint(this);

                if (i == 0 || minLostPoint > lostPoint) {
                    minLostPoint = lostPoint;
                    pattern = i;
                }
            }

            return pattern;
        },

        setupTimingPattern: function() {
            for (var r = 8; r < this.moduleCount - 8; r++) {
                if (this.modules[r][6] != null) {
                    continue;
                }
                this.modules[r][6] = (r % 2 == 0);
            }

            for (var c = 8; c < this.moduleCount - 8; c++) {
                if (this.modules[6][c] != null) {
                    continue;
                }
                this.modules[6][c] = (c % 2 == 0);
            }
        },

        setupPositionAdjustPattern: function() {
            var pos = QRCode.Util.getPatternPosition(this.typeNumber);

            for (var i = 0; i < pos.length; i++) {
                for (var j = 0; j < pos.length; j++) {
                    var row = pos[i];
                    var col = pos[j];

                    if (this.modules[row][col] != null) {
                        continue;
                    }

                    for (var r = -2; r <= 2; r++) {
                        for (var c = -2; c <= 2; c++) {
                            if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
                                this.modules[row + r][col + c] = true;
                            } else {
                                this.modules[row + r][col + c] = false;
                            }
                        }
                    }
                }
            }
        },

        setupTypeNumber: function(test) {
            var bits = QRCode.Util.getBCHTypeNumber(this.typeNumber);

            for (var i = 0; i < 18; i++) {
                var mod = (!test && ((bits >> i) & 1) == 1);
                this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
            }

            for (var i = 0; i < 18; i++) {
                var mod = (!test && ((bits >> i) & 1) == 1);
                this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
            }
        },

        setupTypeInfo: function(test, maskPattern) {
            var data = (this.errorCorrectLevel << 3) | maskPattern;
            var bits = QRCode.Util.getBCHTypeInfo(data);

            for (var i = 0; i < 15; i++) {
                var mod = (!test && ((bits >> i) & 1) == 1);

                if (i < 6) {
                    this.modules[i][8] = mod;
                } else if (i < 8) {
                    this.modules[i + 1][8] = mod;
                } else {
                    this.modules[this.moduleCount - 15 + i][8] = mod;
                }
            }

            for (var i = 0; i < 15; i++) {
                var mod = (!test && ((bits >> i) & 1) == 1);

                if (i < 8) {
                    this.modules[8][this.moduleCount - i - 1] = mod;
                } else if (i < 9) {
                    this.modules[8][15 - i - 1 + 1] = mod;
                } else {
                    this.modules[8][15 - i - 1] = mod;
                }
            }

            this.modules[this.moduleCount - 8][8] = (!test);
        },

        mapData: function(data, maskPattern) {
            var inc = -1;
            var row = this.moduleCount - 1;
            var bitIndex = 7;
            var byteIndex = 0;

            for (var col = this.moduleCount - 1; col > 0; col -= 2) {
                if (col == 6) col--;

                while (true) {
                    for (var c = 0; c < 2; c++) {
                        if (this.modules[row][col - c] == null) {
                            var dark = false;

                            if (byteIndex < data.length) {
                                dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
                            }

                            var mask = QRCode.Util.getMask(maskPattern, row, col - c);

                            if (mask) {
                                dark = !dark;
                            }

                            this.modules[row][col - c] = dark;
                            bitIndex--;

                            if (bitIndex == -1) {
                                byteIndex++;
                                bitIndex = 7;
                            }
                        }
                    }

                    row += inc;

                    if (row < 0 || this.moduleCount <= row) {
                        row -= inc;
                        inc = -inc;
                        break;
                    }
                }
            }
        }
    };

    QRCode.QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
        var rsBlocks = QRCode.RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
        var buffer = new QRCode.BitBuffer();

        for (var i = 0; i < dataList.length; i++) {
            var data = dataList[i];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRCode.Util.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
        }

        var totalDataCount = 0;
        for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
        }

        if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
        }

        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
        }

        while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
        }

        while (true) {
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
                break;
            }
            buffer.put(QRCode.PAD0, 8);

            if (buffer.getLengthInBits() >= totalDataCount * 8) {
                break;
            }
            buffer.put(QRCode.PAD1, 8);
        }

        return QRCode.QRCodeModel.createBytes(buffer, rsBlocks);
    };

    QRCode.PAD0 = 0xEC;
    QRCode.PAD1 = 0x11;

    QRCode.QRCodeModel.createBytes = function(buffer, rsBlocks) {
        var offset = 0;
        var maxDcCount = 0;
        var maxEcCount = 0;
        var dcdata = new Array(rsBlocks.length);
        var ecdata = new Array(rsBlocks.length);

        for (var r = 0; r < rsBlocks.length; r++) {
            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;

            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);

            dcdata[r] = new Array(dcCount);

            for (var i = 0; i < dcdata[r].length; i++) {
                dcdata[r][i] = 0xff & buffer.buffer[i + offset];
            }
            offset += dcCount;

            var rsPoly = QRCode.Util.getErrorCorrectPolynomial(ecCount);
            var rawPoly = new QRCode.Polynomial(dcdata[r], rsPoly.getLength() - 1);
            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);

            for (var i = 0; i < ecdata[r].length; i++) {
                var modIndex = i + modPoly.getLength() - ecdata[r].length;
                ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
            }
        }

        var totalCodeCount = 0;
        for (var i = 0; i < rsBlocks.length; i++) {
            totalCodeCount += rsBlocks[i].totalCount;
        }

        var data = new Array(totalCodeCount);
        var index = 0;

        for (var i = 0; i < maxDcCount; i++) {
            for (var r = 0; r < rsBlocks.length; r++) {
                if (i < dcdata[r].length) {
                    data[index++] = dcdata[r][i];
                }
            }
        }

        for (var i = 0; i < maxEcCount; i++) {
            for (var r = 0; r < rsBlocks.length; r++) {
                if (i < ecdata[r].length) {
                    data[index++] = ecdata[r][i];
                }
            }
        }

        return data;
    };

    // QRCode 8bit Byte
    QRCode.QRCode8bitByte = function(data) {
        this.mode = QRCode.Mode.MODE_8BIT_BYTE;
        this.data = data;
        this.parsedData = [];

        for (var i = 0, l = this.data.length; i < l; i++) {
            var byteArray = [];
            var code = this.data.charCodeAt(i);

            if (code > 0x10000) {
                byteArray[0] = 0xF0 | ((code & 0x1C0000) >>> 18);
                byteArray[1] = 0x80 | ((code & 0x3F000) >>> 12);
                byteArray[2] = 0x80 | ((code & 0xFC0) >>> 6);
                byteArray[3] = 0x80 | (code & 0x3F);
            } else if (code > 0x800) {
                byteArray[0] = 0xE0 | ((code & 0xF000) >>> 12);
                byteArray[1] = 0x80 | ((code & 0xFC0) >>> 6);
                byteArray[2] = 0x80 | (code & 0x3F);
            } else if (code > 0x80) {
                byteArray[0] = 0xC0 | ((code & 0x7C0) >>> 6);
                byteArray[1] = 0x80 | (code & 0x3F);
            } else {
                byteArray[0] = code;
            }

            this.parsedData.push(byteArray);
        }

        this.parsedData = Array.prototype.concat.apply([], this.parsedData);

        if (this.parsedData.length != this.data.length) {
            this.parsedData.unshift(0xEF, 0xBB, 0xBF);
        }
    };

    QRCode.QRCode8bitByte.prototype = {
        getLength: function() {
            return this.parsedData.length;
        },
        write: function(buffer) {
            for (var i = 0, l = this.parsedData.length; i < l; i++) {
                buffer.put(this.parsedData[i], 8);
            }
        }
    };

    // QRCode Mode
    QRCode.Mode = {
        MODE_NUMBER: 1 << 0,
        MODE_ALPHA_NUM: 1 << 1,
        MODE_8BIT_BYTE: 1 << 2,
        MODE_KANJI: 1 << 3
    };

    // QRCode Util
    QRCode.Util = {
        PATTERN_POSITION_TABLE: [
            [],
            [6, 18],
            [6, 22],
            [6, 26],
            [6, 30],
            [6, 34],
            [6, 22, 38],
            [6, 24, 42],
            [6, 26, 46],
            [6, 28, 50],
            [6, 30, 54],
            [6, 32, 58],
            [6, 34, 62],
            [6, 26, 46, 66],
            [6, 26, 48, 70],
            [6, 26, 50, 74],
            [6, 30, 54, 78],
            [6, 30, 56, 82],
            [6, 30, 58, 86],
            [6, 34, 62, 90],
            [6, 28, 50, 72, 94],
            [6, 26, 50, 74, 98],
            [6, 30, 54, 78, 102],
            [6, 28, 54, 80, 106],
            [6, 32, 58, 84, 110],
            [6, 30, 58, 86, 114],
            [6, 34, 62, 90, 118],
            [6, 26, 50, 74, 98, 122],
            [6, 30, 54, 78, 102, 126],
            [6, 26, 52, 78, 104, 130],
            [6, 30, 56, 82, 108, 134],
            [6, 34, 60, 86, 112, 138],
            [6, 30, 58, 86, 114, 142],
            [6, 34, 62, 90, 118, 146],
            [6, 30, 54, 78, 102, 126, 150],
            [6, 24, 50, 76, 102, 128, 154],
            [6, 28, 54, 80, 106, 132, 158],
            [6, 32, 58, 84, 110, 136, 162],
            [6, 26, 54, 82, 110, 138, 166],
            [6, 30, 58, 86, 114, 142, 170]
        ],

        G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
        G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
        G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),

        getBCHTypeInfo: function(data) {
            var d = data << 10;
            while (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G15) >= 0) {
                d ^= (QRCode.Util.G15 << (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G15)));
            }
            return ((data << 10) | d) ^ QRCode.Util.G15_MASK;
        },

        getBCHTypeNumber: function(data) {
            var d = data << 12;
            while (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G18) >= 0) {
                d ^= (QRCode.Util.G18 << (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G18)));
            }
            return (data << 12) | d;
        },

        getBCHDigit: function(data) {
            var digit = 0;
            while (data != 0) {
                digit++;
                data >>>= 1;
            }
            return digit;
        },

        getPatternPosition: function(typeNumber) {
            return QRCode.Util.PATTERN_POSITION_TABLE[typeNumber - 1];
        },

        getMask: function(maskPattern, i, j) {
            switch (maskPattern) {
                case 0:
                    return (i + j) % 2 == 0;
                case 1:
                    return i % 2 == 0;
                case 2:
                    return j % 3 == 0;
                case 3:
                    return (i + j) % 3 == 0;
                case 4:
                    return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
                case 5:
                    return (i * j) % 2 + (i * j) % 3 == 0;
                case 6:
                    return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
                case 7:
                    return ((i * j) % 3 + (i + j) % 2) % 2 == 0;
                default:
                    throw new Error("bad maskPattern:" + maskPattern);
            }
        },

        getErrorCorrectPolynomial: function(errorCorrectLength) {
            var a = new QRCode.Polynomial([1], 0);
            for (var i = 0; i < errorCorrectLength; i++) {
                a = a.multiply(new QRCode.Polynomial([1, QRCode.GF256.gexp(i)], 0));
            }
            return a;
        },

        getLengthInBits: function(mode, type) {
            if (1 <= type && type < 10) {
                switch (mode) {
                    case QRCode.Mode.MODE_NUMBER:
                        return 10;
                    case QRCode.Mode.MODE_ALPHA_NUM:
                        return 9;
                    case QRCode.Mode.MODE_8BIT_BYTE:
                        return 8;
                    case QRCode.Mode.MODE_KANJI:
                        return 8;
                    default:
                        throw new Error("mode:" + mode);
                }
            } else if (type < 27) {
                switch (mode) {
                    case QRCode.Mode.MODE_NUMBER:
                        return 12;
                    case QRCode.Mode.MODE_ALPHA_NUM:
                        return 11;
                    case QRCode.Mode.MODE_8BIT_BYTE:
                        return 16;
                    case QRCode.Mode.MODE_KANJI:
                        return 10;
                    default:
                        throw new Error("mode:" + mode);
                }
            } else if (type < 41) {
                switch (mode) {
                    case QRCode.Mode.MODE_NUMBER:
                        return 14;
                    case QRCode.Mode.MODE_ALPHA_NUM:
                        return 13;
                    case QRCode.Mode.MODE_8BIT_BYTE:
                        return 16;
                    case QRCode.Mode.MODE_KANJI:
                        return 12;
                    default:
                        throw new Error("mode:" + mode);
                }
            } else {
                throw new Error("type:" + type);
            }
        },

        getLostPoint: function(qrCode) {
            var moduleCount = qrCode.getModuleCount();
            var lostPoint = 0;

            for (var row = 0; row < moduleCount; row++) {
                for (var col = 0; col < moduleCount; col++) {
                    var sameCount = 0;
                    var dark = qrCode.isDark(row, col);

                    for (var r = -1; r <= 1; r++) {
                        if (row + r < 0 || moduleCount <= row + r) {
                            continue;
                        }

                        for (var c = -1; c <= 1; c++) {
                            if (col + c < 0 || moduleCount <= col + c) {
                                continue;
                            }

                            if (r == 0 && c == 0) {
                                continue;
                            }

                            if (dark == qrCode.isDark(row + r, col + c)) {
                                sameCount++;
                            }
                        }
                    }

                    if (sameCount > 5) {
                        lostPoint += (3 + sameCount - 5);
                    }
                }
            }

            for (var row = 0; row < moduleCount - 1; row++) {
                for (var col = 0; col < moduleCount - 1; col++) {
                    var count = 0;
                    if (qrCode.isDark(row, col)) count++;
                    if (qrCode.isDark(row + 1, col)) count++;
                    if (qrCode.isDark(row, col + 1)) count++;
                    if (qrCode.isDark(row + 1, col + 1)) count++;
                    if (count == 0 || count == 4) {
                        lostPoint += 3;
                    }
                }
            }

            for (var row = 0; row < moduleCount; row++) {
                for (var col = 0; col < moduleCount - 6; col++) {
                    if (qrCode.isDark(row, col) &&
                        !qrCode.isDark(row, col + 1) &&
                        qrCode.isDark(row, col + 2) &&
                        qrCode.isDark(row, col + 3) &&
                        qrCode.isDark(row, col + 4) &&
                        !qrCode.isDark(row, col + 5) &&
                        qrCode.isDark(row, col + 6)) {
                        lostPoint += 40;
                    }
                }
            }

            for (var col = 0; col < moduleCount; col++) {
                for (var row = 0; row < moduleCount - 6; row++) {
                    if (qrCode.isDark(row, col) &&
                        !qrCode.isDark(row + 1, col) &&
                        qrCode.isDark(row + 2, col) &&
                        qrCode.isDark(row + 3, col) &&
                        qrCode.isDark(row + 4, col) &&
                        !qrCode.isDark(row + 5, col) &&
                        qrCode.isDark(row + 6, col)) {
                        lostPoint += 40;
                    }
                }
            }

            var darkCount = 0;

            for (var col = 0; col < moduleCount; col++) {
                for (var row = 0; row < moduleCount; row++) {
                    if (qrCode.isDark(row, col)) {
                        darkCount++;
                    }
                }
            }

            var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
            lostPoint += ratio * 10;

            return lostPoint;
        },

        getTypeNumber: function(sText, nCorrectLevel) {
            var nType = 1;
            var length = QRCode.Util.getUTF8Length(sText);

            for (nType = 1; nType <= 40; nType++) {
                var rsBlocks = QRCode.RSBlock.getRSBlocks(nType, nCorrectLevel);
                var buffer = new QRCode.BitBuffer();
                buffer.put(4, 4);
                buffer.put(length, QRCode.Util.getLengthInBits(4, nType));

                for (var i = 0, l = sText.length; i < l; i++) {
                    var byteArray = [];
                    var code = sText.charCodeAt(i);

                    if (code > 0x10000) {
                        byteArray[0] = 0xF0 | ((code & 0x1C0000) >>> 18);
                        byteArray[1] = 0x80 | ((code & 0x3F000) >>> 12);
                        byteArray[2] = 0x80 | ((code & 0xFC0) >>> 6);
                        byteArray[3] = 0x80 | (code & 0x3F);
                    } else if (code > 0x800) {
                        byteArray[0] = 0xE0 | ((code & 0xF000) >>> 12);
                        byteArray[1] = 0x80 | ((code & 0xFC0) >>> 6);
                        byteArray[2] = 0x80 | (code & 0x3F);
                    } else if (code > 0x80) {
                        byteArray[0] = 0xC0 | ((code & 0x7C0) >>> 6);
                        byteArray[1] = 0x80 | (code & 0x3F);
                    } else {
                        byteArray[0] = code;
                    }

                    for (var j = 0; j < byteArray.length; j++) {
                        buffer.put(byteArray[j], 8);
                    }
                }

                var totalDataCount = 0;
                for (var i = 0; i < rsBlocks.length; i++) {
                    totalDataCount += rsBlocks[i].dataCount;
                }

                if (buffer.getLengthInBits() <= totalDataCount * 8) {
                    break;
                }
            }

            return nType;
        },

        getUTF8Length: function(sText) {
            var replacedText = encodeURI(sText).toString().replace(/\%[0-9a-fA-F]{2}/g, 'a');
            return replacedText.length + (replacedText.length != sText ? 3 : 0);
        }
    };

    // RSBlock
    QRCode.RSBlock = function(totalCount, dataCount) {
        this.totalCount = totalCount;
        this.dataCount = dataCount;
    };

    QRCode.RSBlock.RS_BLOCK_TABLE = [
        [1, 26, 19],
        [1, 26, 16],
        [1, 26, 13],
        [1, 26, 9],
        [1, 44, 34],
        [1, 44, 28],
        [1, 44, 22],
        [1, 44, 16],
        [1, 70, 55],
        [1, 70, 44],
        [2, 35, 17],
        [2, 35, 13],
        [1, 100, 80],
        [2, 50, 32],
        [2, 50, 24],
        [4, 25, 9],
        [1, 134, 108],
        [2, 67, 43],
        [2, 33, 15, 2, 34, 16],
        [2, 33, 11, 2, 34, 12],
        [2, 86, 68],
        [4, 43, 27],
        [4, 43, 19],
        [4, 43, 15],
        [2, 98, 78],
        [4, 49, 31],
        [2, 32, 14, 4, 33, 15],
        [4, 39, 13, 1, 40, 14],
        [2, 121, 97],
        [2, 60, 38, 2, 61, 39],
        [4, 40, 18, 2, 41, 19],
        [4, 40, 14, 2, 41, 15],
        [2, 146, 116],
        [3, 58, 36, 2, 59, 37],
        [4, 36, 16, 4, 37, 17],
        [4, 36, 12, 4, 37, 13],
        [2, 86, 68, 2, 87, 69],
        [4, 69, 43, 1, 70, 44],
        [6, 43, 19, 2, 44, 20],
        [6, 43, 15, 2, 44, 16]
    ];

    QRCode.RSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
        var rsBlock = QRCode.RSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);

        if (rsBlock == undefined) {
            throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
        }

        var length = rsBlock.length / 3;
        var list = [];

        for (var i = 0; i < length; i++) {
            var count = rsBlock[i * 3 + 0];
            var totalCount = rsBlock[i * 3 + 1];
            var dataCount = rsBlock[i * 3 + 2];

            for (var j = 0; j < count; j++) {
                list.push(new QRCode.RSBlock(totalCount, dataCount));
            }
        }

        return list;
    };

    QRCode.RSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
        switch (errorCorrectLevel) {
            case QRCode.CorrectLevel.L:
                return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
            case QRCode.CorrectLevel.M:
                return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
            case QRCode.CorrectLevel.Q:
                return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
            case QRCode.CorrectLevel.H:
                return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
            default:
                return undefined;
        }
    };

    // BitBuffer
    QRCode.BitBuffer = function() {
        this.buffer = [];
        this.length = 0;
    };

    QRCode.BitBuffer.prototype = {
        get: function(index) {
            var bufIndex = Math.floor(index / 8);
            return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
        },

        put: function(num, length) {
            for (var i = 0; i < length; i++) {
                this.putBit(((num >>> (length - i - 1)) & 1) == 1);
            }
        },

        getLengthInBits: function() {
            return this.length;
        },

        putBit: function(bit) {
            var bufIndex = Math.floor(this.length / 8);
            if (this.buffer.length <= bufIndex) {
                this.buffer.push(0);
            }

            if (bit) {
                this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
            }

            this.length++;
        }
    };

    // GF256
    QRCode.GF256 = function(a, b) {
        if (a.length == undefined) {
            throw new Error(a.length + "/" + b);
        }

        var offset = 0;

        while (offset < a.length && a[offset] == 0) {
            offset++;
        }

        this.num = new Array(a.length - offset + b);

        for (var i = 0; i < a.length - offset; i++) {
            this.num[i] = a[i + offset];
        }
    };

    QRCode.GF256.prototype = {
        get: function(index) {
            return this.num[index];
        },

        getLength: function() {
            return this.num.length;
        },

        multiply: function(e) {
            var num = new Array(this.getLength() + e.getLength() - 1);

            for (var i = 0; i < this.getLength(); i++) {
                for (var j = 0; j < e.getLength(); j++) {
                    num[i + j] ^= QRCode.GF256.gfmul(this.get(i), e.get(j));
                }
            }

            return new QRCode.GF256(num, 0);
        },

        mod: function(e) {
            if (this.getLength() - e.getLength() < 0) {
                return this;
            }

            var ratio = QRCode.GF256.gfmul(this.get(0), QRCode.GF256.gfinv(e.get(0)));
            var num = new Array(this.getLength());

            for (var i = 0; i < this.getLength(); i++) {
                num[i] = this.get(i);
            }

            for (var i = 0; i < e.getLength(); i++) {
                num[i] ^= QRCode.GF256.gfmul(e.get(i), ratio);
            }

            return (new QRCode.GF256(num, 0)).mod(e);
        }
    };

    QRCode.GF256.glog = function(n) {
        if (n < 1) {
            throw new Error("glog(" + n + ")");
        }

        return QRCode.GF256.LOG_TABLE[n];
    };

    QRCode.GF256.gexp = function(n) {
        while (n < 0) {
            n += 255;
        }

        while (n >= 256) {
            n -= 255;
        }

        return QRCode.GF256.EXP_TABLE[n];
    };

    QRCode.GF256.EXP_TABLE = new Array(256);
    QRCode.GF256.LOG_TABLE = new Array(256);

    for (var i = 0; i < 8; i++) {
        QRCode.GF256.EXP_TABLE[i] = 1 << i;
    }

    for (var i = 8; i < 256; i++) {
        QRCode.GF256.EXP_TABLE[i] = QRCode.GF256.EXP_TABLE[i - 4] ^
            QRCode.GF256.EXP_TABLE[i - 5] ^
            QRCode.GF256.EXP_TABLE[i - 6] ^
            QRCode.GF256.EXP_TABLE[i - 8];
    }

    for (var i = 0; i < 255; i++) {
        QRCode.GF256.LOG_TABLE[QRCode.GF256.EXP_TABLE[i]] = i;
    }

    QRCode.GF256.gfmul = function(a, b) {
        if (a == 0 || b == 0) {
            return 0;
        }

        return QRCode.GF256.EXP_TABLE[QRCode.GF256.LOG_TABLE[a] + QRCode.GF256.LOG_TABLE[b]];
    };

    QRCode.GF256.gfinv = function(a) {
        return QRCode.GF256.EXP_TABLE[255 - QRCode.GF256.LOG_TABLE[a]];
    };

    // Polynomial
    QRCode.Polynomial = function(num, shift) {
        if (num.length == undefined) {
            throw new Error(num.length + "/" + shift);
        }

        var offset = 0;

        while (offset < num.length && num[offset] == 0) {
            offset++;
        }

        this.num = new Array(num.length - offset + shift);

        for (var i = 0; i < num.length - offset; i++) {
            this.num[i] = num[i + offset];
        }
    };

    QRCode.Polynomial.prototype = {
        get: function(index) {
            return this.num[index];
        },

        getLength: function() {
            return this.num.length;
        },

        multiply: function(e) {
            var num = new Array(this.getLength() + e.getLength() - 1);

            for (var i = 0; i < this.getLength(); i++) {
                for (var j = 0; j < e.getLength(); j++) {
                    num[i + j] ^= QRCode.GF256.gfmul(this.get(i), e.get(j));
                }
            }

            return new QRCode.Polynomial(num, 0);
        },

        mod: function(e) {
            if (this.getLength() - e.getLength() < 0) {
                return this;
            }

            var ratio = QRCode.GF256.gfmul(this.get(0), QRCode.GF256.gfinv(e.get(0)));
            var num = new Array(this.getLength());

            for (var i = 0; i < this.getLength(); i++) {
                num[i] = this.get(i);
            }

            for (var i = 0; i < e.getLength(); i++) {
                num[i] ^= QRCode.GF256.gfmul(e.get(i), ratio);
            }

            return (new QRCode.Polynomial(num, 0)).mod(e);
        }
    };

    // Drawing
    QRCode.Drawing = function(el, htOption) {
        this._el = el;
        this._htOption = htOption;
    };

    QRCode.Drawing.prototype.draw = function(oQRCode) {
        var _htOption = this._htOption;
        var _el = this._el;
        var nCount = oQRCode.getModuleCount();
        var nWidth = Math.floor(_htOption.width / nCount);
        var nHeight = Math.floor(_htOption.height / nCount);

        this._el.innerHTML = this._createCanvas(nCount);
    };

    QRCode.Drawing.prototype._createCanvas = function(nCount) {
        var canvas = document.createElement("canvas");
        canvas.width = this._htOption.width;
        canvas.height = this._htOption.height;
        var ctx = canvas.getContext("2d");

        var tileW = this._htOption.width / nCount;
        var tileH = this._htOption.height / nCount;

        for (var row = 0; row < nCount; row++) {
            for (var col = 0; col < nCount; col++) {
                var w = (Math.ceil((col + 1) * tileW) - Math.floor(col * tileW));
                var h = (Math.ceil((row + 1) * tileH) - Math.floor(row * tileH));

                ctx.fillStyle = this._oQRCode.isDark(row, col) ? this._htOption.colorDark : this._htOption.colorLight;
                ctx.fillRect(Math.floor(col * tileW), Math.floor(row * tileH), w, h);
            }
        }

        return canvas.outerHTML;
    };

    QRCode.Drawing.prototype.clear = function() {
        this._el.innerHTML = "";
    };

    QRCode.Drawing.prototype.makeImage = function() {
        // Implementation for making image
    };

    // toCanvas function
    QRCode.toCanvas = function(canvas, text, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        options = options || {};
        callback = callback || function() {};

        if (!canvas) {
            return callback(new Error('Canvas element is required'));
        }

        var ctx = canvas.getContext('2d');
        if (!ctx) {
            return callback(new Error('Canvas context is not available'));
        }

        var qr = new QRCode.QRCodeModel(
            QRCode.Util.getTypeNumber(text, options.errorCorrectionLevel || QRCode.CorrectLevel.M),
            options.errorCorrectionLevel || QRCode.CorrectLevel.M
        );

        qr.addData(text);
        qr.make();

        var size = options.width || 256;
        var margin = options.margin || 4;
        var scale = size / (qr.getModuleCount() + 2 * margin);

        canvas.width = size;
        canvas.height = size;

        ctx.fillStyle = (options.color && options.color.light) || '#ffffff';
        ctx.fillRect(0, 0, size, size);

        ctx.fillStyle = (options.color && options.color.dark) || '#000000';

        for (var row = 0; row < qr.getModuleCount(); row++) {
            for (var col = 0; col < qr.getModuleCount(); col++) {
                if (qr.isDark(row, col)) {
                    ctx.fillRect(
                        (col + margin) * scale,
                        (row + margin) * scale,
                        scale,
                        scale
                    );
                }
            }
        }

        callback();
    };

    // toString function
    QRCode.toString = function(text, options) {
        options = options || {};

        var qr = new QRCode.QRCodeModel(
            QRCode.Util.getTypeNumber(text, options.errorCorrectionLevel || QRCode.CorrectLevel.M),
            options.errorCorrectionLevel || QRCode.CorrectLevel.M
        );

        qr.addData(text);
        qr.make();

        var size = qr.getModuleCount();
        var margin = options.margin || 4;
        var scale = options.scale || 4;
        var out = '';

        for (var row = 0; row < size + 2 * margin; row++) {
            for (var col = 0; col < size + 2 * margin; col++) {
                var isDark = row >= margin && row < size + margin &&
                    col >= margin && col < size + margin &&
                    qr.isDark(row - margin, col - margin);

                out += isDark ? '██' : '  ';
            }
            out += '\n';
        }

        return out;
    };

    // Export
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = QRCode;
    }

    if (typeof window !== 'undefined') {
        window.QRCode = QRCode;
    }
})();
